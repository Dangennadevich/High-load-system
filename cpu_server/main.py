from fastapi import FastAPI
from pydantic import BaseModel
from dotenv import load_dotenv
from databases import Database

import os
import aio_pika
import json
import uuid
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

logger.info("[Setup] Getting .env settings")

load_dotenv()

RABBITMQ_DEFAULT_USER = os.getenv("RABBITMQ_DEFAULT_USER")
RABBITMQ_DEFAULT_PASS = os.getenv("RABBITMQ_DEFAULT_PASS")
if not RABBITMQ_DEFAULT_USER or not RABBITMQ_DEFAULT_PASS:
    raise ValueError("RABBITMQ_DEFAULT_USER and RABBITMQ_DEFAULT_PASS must be set in the .env file")

POSTGRES_PASSWORD = os.getenv("POSTGRES_PASSWORD")
POSTGRES_USER = os.getenv("POSTGRES_USER")
if not POSTGRES_PASSWORD or not POSTGRES_USER:
    raise ValueError("POSTGRES_PASSWORD and POSTGRES_USER must be set in the .env file")

# Connect to PostgreSQL
logger.info("[Setup] Connect to PostgreSQL")
DATABASE_URL = f"postgresql://{POSTGRES_USER}:{POSTGRES_PASSWORD}@postgres_db/rabbitmq_db"
database = Database(DATABASE_URL)

app = FastAPI()

class TextInput(BaseModel):
    '''Model for input data'''
    text: str

@app.on_event("startup")
async def startup():
    await database.connect()

@app.on_event("shutdown")
async def shutdown():
    await database.disconnect()

async def connect_to_rabbitmq():
    '''Get connect to RabbitMQ from rabbitmq container'''
    return await aio_pika.connect_robust(
        f"amqp://{RABBITMQ_DEFAULT_USER}:{RABBITMQ_DEFAULT_PASS}@rabbitmq/"
    )

@app.get("/")
def read_root():
    return {"message": "Probability prediction is the text generated by the model!"}

# The route for processing the POST request
@app.post("/predict")
async def predict(text_input: TextInput):
    '''Post request processing'''
    try:
        # Generate task id
        task_id = str(uuid.uuid4())

        logger.info(f"Received a message: -task_id: {task_id} -message: {text_input.text}")

        # Save task to DB with status "pending"
        query = "INSERT INTO tasks_detecting_generated_text (task_id, status) VALUES (:task_id, :status)"
        await database.execute(query, values={"task_id": task_id, "status": "pending"})

        connection = await connect_to_rabbitmq()
        channel = await connection.channel()
        exchange = await channel.declare_exchange(
            "direct_exchange", 
            aio_pika.ExchangeType.DIRECT, 
            durable=True
        )

        # Message for rabbitmq and GPU server
        message = {"task_id": task_id, "text": text_input.text}

        # publish message
        await exchange.publish(
            aio_pika.Message(
                body=json.dumps(message).encode(),
                correlation_id=task_id
            ),
            routing_key="tasks_pred_gen_txt",
        )

        logger.info(f"Sent message with task_id: {task_id}")

        return {"task_id": task_id}
    
    except Exception as e:
        logger.error(f"Error in predict: {e}")
        return {"error": str(e)}
    finally:
        if connection:
            await connection.close()

@app.get("/status/{task_id}")
async def get_status(task_id: str):
    '''Get status of the task'''
    logger.info(f"Get info about task_id: {task_id}")

    query = "SELECT status, result FROM tasks_detecting_generated_text WHERE task_id = :task_id"
    task = await database.fetch_one(query, values={"task_id": task_id})

    if task is None:
        logger.info(f"Task not found, task_id: {task_id}")
        return {"error": "Task not found"}
    
    logger.info(f"task_id: {task_id}, status: {task['status']}, result: {task['result']}")

    return {"task_id": task_id, "status": task["status"], "result": task["result"]}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000, debug=False)